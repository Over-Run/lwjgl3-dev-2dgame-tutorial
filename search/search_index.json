{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LWJGL3 Develop 2D Game Tutorial A tutorial on making a 2D game from scratch using LWJGL3 \u8b66\u544a\uff1a\u672c\u6559\u7a0b\u7531\u4e0d\u540c\u4f5c\u8005\u7f16\u5199\uff0c\u8868\u8fbe\u65b9\u5f0f\u53ef\u80fd\u6709\u6240\u51fa\u5165\u3002 \u6700\u597d\u4e0d\u8981\u628a\u8fd9\u4e2a\u5f53\u6210\u6559\u7a0b\u770b","title":"\u7b80\u4ecb"},{"location":"#lwjgl3-develop-2d-game-tutorial","text":"A tutorial on making a 2D game from scratch using LWJGL3 \u8b66\u544a\uff1a\u672c\u6559\u7a0b\u7531\u4e0d\u540c\u4f5c\u8005\u7f16\u5199\uff0c\u8868\u8fbe\u65b9\u5f0f\u53ef\u80fd\u6709\u6240\u51fa\u5165\u3002 \u6700\u597d\u4e0d\u8981\u628a\u8fd9\u4e2a\u5f53\u6210\u6559\u7a0b\u770b","title":"LWJGL3 Develop 2D Game Tutorial"},{"location":"chapter1/lwjgl/","text":"\u914d\u7f6e\u73af\u5883 \u4e0b\u8f7d LWJGL LWJGL\u63d0\u4f9b\u4e86\u4e00\u4e2a \u5728\u7ebf\u914d\u7f6e\u5e93\u7684\u7f51\u5740 \u5f53\u7136\uff0c\u8fd9\u4e48\u591a\u914d\u7f6e\u9009\u9879\uff0c\u4e0d\u7ed9\u70b9\u5efa\u8bae\u4f60\u80af\u5b9a\u4f1a\u61f5\u5708 \u9996\u5148\u662f Show description \u5f00\u5173\uff0c\u5bf9\uff0c\u5c31\u662f\u8fd9\u4e2a \u8fd9\u4e2a\u5f00\u5173\u7528\u4e8e\u8d1f\u8d23\u89e3\u91ca\u8fd9\u4e9b\u5947\u5947\u602a\u602a\u7684\u9009\u9879\u662f\u4ec0\u4e48\u610f\u601d \u5982\u679c\u82f1\u6587\u8db3\u591f\u597d\uff0c\u53ef\u4ee5\u9009\u62e9\u5f00\u8fd9\u4e2a\u5f00\u5173\u7136\u540e\u6839\u636e\u5185\u5bb9\u81ea\u5df1\u9009 \u96be\u5ea6\u7ea6\u7b49\u4e8e\u521d\u4e09\u82f1\u8bed\u8003\u8bd5 \u7136\u540e\u662f Mode \u9009\u9879 \u7b2c\u4e00\u4e2a\u662f\u4ee5 \u538b\u7f29\u6587\u4ef6 \u5f62\u5f0f\u6253\u5305\u4e0b\u8f7d \u7b2c\u4e8c\u4e2a\u662f\u7528 Maven \u6765\u81ea\u52a8\u4e0b\u8f7d\u4f9d\u8d56 \u7b2c\u4e09\u4e2a\u662f\u7528 Gradle \u6765\u81ea\u52a8\u4e0b\u8f7d\u4f9d\u8d56 \u7b2c\u4e09\u4e2a\u662f\u7528 Apache Ivy \u6765\u81ea\u52a8\u4e0b\u8f7d\u4f9d\u8d56 Option \u9009\u9879\u56e0Mode\u800c\u5f02 \u4e0d\u8fc7\u60f3\u5fc5\u5927\u5bb6\u90fd\u80fd\u770b\u61c2 \u63a5\u4e0b\u6765\u662f Natives \u9009\u9879 \u56e0\u4e3a\u5173\u4e8e\u56fe\u5f62\u6e32\u67d3\u7684\u5e93\u5fc5\u5b9a\u4e0e\u5e73\u53f0\u6709\u5173 \u6240\u4ee5\u8981\u4f60\u9009\u62e9\u4f60\u7684\u6e38\u620f\u53ef\u80fd\u4f1a\u53d1\u5e03\u5230\u7684\u5e73\u53f0 \u4e00\u822c\u800c\u8a00\uff0c\u52fe\u9009\u8fd9\u4e09\u4e2a\u5c31\u53ef\u4ee5\u4e86 \u5982\u679c\u4f60\u60f3\uff0c\u53ef\u4ee5\u5168\u9009 \u4e4b\u540e\u662f Presets \u9009\u9879 \u9009\u62e9 Custom \u73b0\u5728\u662f Addons \u9009\u9879 \u4e00\u5b9a\u8981\u9009\u62e9JOML \u6570\u5b66\u5e93\uff08\u5230\u540e\u9762\u6570\u5b66\u662f\u771f\u7684\u91cd\u8981\uff09 Version \u9009\u62e9 3.2.3 \u6700\u540e\u662f Contents \u6211\u4e00\u822c\u9009\u62e9 Assimp glfw LLVM LZ4 \u6216 ZStandard OpenAL OpenGL STB Vulkan Vulkan Memory Allocator \u5176\u4e2d\u5f3a\u70c8\u63a8\u8350\uff08\u51e0\u4e4e\u5fc5\u4e0d\u53ef\u5c11\uff09 glfw OpenAL (\u97f3\u6548) OpenGL STB (\u7eb9\u7406\u7b49) \u914d\u7f6e\u73af\u5883 \u5728 Mode \u4e2d\u9009\u62e9 \u538b\u7f29\u6587\u4ef6 \u7684\u6839\u636e\u81ea\u5df1\u7684IDE\u914d\u7f6e \u5269\u4e0b\u7684\u5219\u628a\u5bf9\u5e94\u7684\u6587\u4ef6\uff08\u5982 build.gradle \uff09\u590d\u5236\u5230\u9879\u76ee\u6839\u76ee\u5f55\u4e0b","title":"\u914d\u7f6e\u73af\u5883"},{"location":"chapter1/lwjgl/#_1","text":"","title":"\u914d\u7f6e\u73af\u5883"},{"location":"chapter1/lwjgl/#lwjgl","text":"LWJGL\u63d0\u4f9b\u4e86\u4e00\u4e2a \u5728\u7ebf\u914d\u7f6e\u5e93\u7684\u7f51\u5740 \u5f53\u7136\uff0c\u8fd9\u4e48\u591a\u914d\u7f6e\u9009\u9879\uff0c\u4e0d\u7ed9\u70b9\u5efa\u8bae\u4f60\u80af\u5b9a\u4f1a\u61f5\u5708 \u9996\u5148\u662f Show description \u5f00\u5173\uff0c\u5bf9\uff0c\u5c31\u662f\u8fd9\u4e2a \u8fd9\u4e2a\u5f00\u5173\u7528\u4e8e\u8d1f\u8d23\u89e3\u91ca\u8fd9\u4e9b\u5947\u5947\u602a\u602a\u7684\u9009\u9879\u662f\u4ec0\u4e48\u610f\u601d \u5982\u679c\u82f1\u6587\u8db3\u591f\u597d\uff0c\u53ef\u4ee5\u9009\u62e9\u5f00\u8fd9\u4e2a\u5f00\u5173\u7136\u540e\u6839\u636e\u5185\u5bb9\u81ea\u5df1\u9009 \u96be\u5ea6\u7ea6\u7b49\u4e8e\u521d\u4e09\u82f1\u8bed\u8003\u8bd5 \u7136\u540e\u662f Mode \u9009\u9879 \u7b2c\u4e00\u4e2a\u662f\u4ee5 \u538b\u7f29\u6587\u4ef6 \u5f62\u5f0f\u6253\u5305\u4e0b\u8f7d \u7b2c\u4e8c\u4e2a\u662f\u7528 Maven \u6765\u81ea\u52a8\u4e0b\u8f7d\u4f9d\u8d56 \u7b2c\u4e09\u4e2a\u662f\u7528 Gradle \u6765\u81ea\u52a8\u4e0b\u8f7d\u4f9d\u8d56 \u7b2c\u4e09\u4e2a\u662f\u7528 Apache Ivy \u6765\u81ea\u52a8\u4e0b\u8f7d\u4f9d\u8d56 Option \u9009\u9879\u56e0Mode\u800c\u5f02 \u4e0d\u8fc7\u60f3\u5fc5\u5927\u5bb6\u90fd\u80fd\u770b\u61c2 \u63a5\u4e0b\u6765\u662f Natives \u9009\u9879 \u56e0\u4e3a\u5173\u4e8e\u56fe\u5f62\u6e32\u67d3\u7684\u5e93\u5fc5\u5b9a\u4e0e\u5e73\u53f0\u6709\u5173 \u6240\u4ee5\u8981\u4f60\u9009\u62e9\u4f60\u7684\u6e38\u620f\u53ef\u80fd\u4f1a\u53d1\u5e03\u5230\u7684\u5e73\u53f0 \u4e00\u822c\u800c\u8a00\uff0c\u52fe\u9009\u8fd9\u4e09\u4e2a\u5c31\u53ef\u4ee5\u4e86 \u5982\u679c\u4f60\u60f3\uff0c\u53ef\u4ee5\u5168\u9009 \u4e4b\u540e\u662f Presets \u9009\u9879 \u9009\u62e9 Custom \u73b0\u5728\u662f Addons \u9009\u9879 \u4e00\u5b9a\u8981\u9009\u62e9JOML \u6570\u5b66\u5e93\uff08\u5230\u540e\u9762\u6570\u5b66\u662f\u771f\u7684\u91cd\u8981\uff09 Version \u9009\u62e9 3.2.3 \u6700\u540e\u662f Contents \u6211\u4e00\u822c\u9009\u62e9 Assimp glfw LLVM LZ4 \u6216 ZStandard OpenAL OpenGL STB Vulkan Vulkan Memory Allocator \u5176\u4e2d\u5f3a\u70c8\u63a8\u8350\uff08\u51e0\u4e4e\u5fc5\u4e0d\u53ef\u5c11\uff09 glfw OpenAL (\u97f3\u6548) OpenGL STB (\u7eb9\u7406\u7b49)","title":"\u4e0b\u8f7d LWJGL"},{"location":"chapter1/lwjgl/#_2","text":"\u5728 Mode \u4e2d\u9009\u62e9 \u538b\u7f29\u6587\u4ef6 \u7684\u6839\u636e\u81ea\u5df1\u7684IDE\u914d\u7f6e \u5269\u4e0b\u7684\u5219\u628a\u5bf9\u5e94\u7684\u6587\u4ef6\uff08\u5982 build.gradle \uff09\u590d\u5236\u5230\u9879\u76ee\u6839\u76ee\u5f55\u4e0b","title":"\u914d\u7f6e\u73af\u5883"},{"location":"chapter2/hello_triangle/","text":"\u4f60\u597d\uff0c\u4e09\u89d2\u5f62 \u73b0\u5728\u6211\u4eec\u60f3\u7ed8\u5236\u4e00\u4e2a\u4e94\u00d7N\u5f69\u7684\u4e09\u89d2\u5f62\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u9996\u6b21\u4e5f\u662f\u6700\u540e\u4e00\u6b21\u4f7f\u7528\u56fa\u5b9a\u7ba1\u7ebf\u6765\u7ed8\u5236\u3002 \u5982\u679c\u60f3\u4e86\u89e3\u66f4\u591a\u56fa\u5b9a\u7ba1\u7ebf\u7684\u4f7f\u7528\u793a\u4f8b\uff0c\u8bf7\u53c2\u8003 Minecraft2D . \u4e0b\u4e00\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u4ecb\u7ecd\u7740\u8272\u5668\u2014\u2014\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u7ba1\u7ebf \u9996\u5148\uff0c\u6211\u4eec\u5b9a\u4f4d\u5230\u8fd9\u4e2a\u4f4d\u7f6e\uff1a public class HelloWorld { // .. private void loop() { // .. glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while (!glfwWindowShouldClose(window)) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } // .. } // .. } \u7136\u540e\uff0c\u628a glClearColor(1.0f, 0.0f, 0.0f, 0.0f); \u6539\u4e3a glClearColor(0.0f, 0.0f, 0.0f, 0.0f); \uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u4eae\u778e\u773c\u4e86\u3002 \u63a5\u7740\u5728 glClear \u540e\u6dfb\u52a0\u4e0b\u9762\u51e0\u6761\u8bed\u53e5\uff1a public class HelloWorld { // .. private void loop() { // .. while (!glfwWindowShouldClose(window)) { // .. glBegin(GL_TRIANGLES); // \u5f00\u59cb\u7ed8\u5236\u4e09\u89d2\u5f62 // \u6ce8\u610f\uff1a\u9700\u8981\u9006\u65f6\u9488\u7ed8\u5236 glColor3f(1, 0, 0); // \u7ea2 glVertex2f(0, 1); // \u4e2d\u4e0a glColor3f(0, 1, 0); // \u7eff glVertex2f(-1, -1); // \u5de6\u4e0b glColor3f(0, 0, 1); // \u84dd glVertex2f(1, -1); // \u53f3\u4e0b glEnd(); // \u7ed8\u5236\u7ed3\u675f // .. } // .. } // .. } \u542f\u52a8\u540e\uff0c\u4f1a\u5f97\u5230\u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62\u3002 glColor4f() \u7528\u4e8e\u8bbe\u7f6e\u989c\u8272, \u4ee5OpenGL\u7684RGBA\u6a21\u5f0f glVertex3f() \u8bbe\u7f6e\u9876\u70b9\u4f4d\u7f6e, \u4ee5x, y, z\u7684\u683c\u5f0f\u3002 \u4e5f\u8bb8\u4f60\u4f1a\u7591\u60d1: \u8fd9\u4e0d\u662f2d\u6e38\u620f\u5417\uff1fz\u8f74\u6709\u4ec0\u4e48\u7528 \u7b54\u6848\u7b80\u5355\u81f3\u6781\uff1a\u5c06\u80cc\u666f\u7684z\u8f74\u53d8\u6df1\uff0c\u4ee5\u4f7f\u5176\u4ed6\u7269\u4f53\u8986\u76d6\u4e8e\u80cc\u666f\u4e0a\u3002 \u8bb0\u5f97\u5f00\u6df1\u5ea6\u6d4b\u8bd5 \u5931\u8d25\u4e86\uff1f\u8fd8\u4e0d\u5feb\u629b issue !","title":"\u4f60\u597d\uff0c\u4e09\u89d2\u5f62"},{"location":"chapter2/hello_triangle/#_1","text":"\u73b0\u5728\u6211\u4eec\u60f3\u7ed8\u5236\u4e00\u4e2a\u4e94\u00d7N\u5f69\u7684\u4e09\u89d2\u5f62\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u9996\u6b21\u4e5f\u662f\u6700\u540e\u4e00\u6b21\u4f7f\u7528\u56fa\u5b9a\u7ba1\u7ebf\u6765\u7ed8\u5236\u3002 \u5982\u679c\u60f3\u4e86\u89e3\u66f4\u591a\u56fa\u5b9a\u7ba1\u7ebf\u7684\u4f7f\u7528\u793a\u4f8b\uff0c\u8bf7\u53c2\u8003 Minecraft2D . \u4e0b\u4e00\u8282\uff0c\u6211\u4eec\u5c06\u4f1a\u4ecb\u7ecd\u7740\u8272\u5668\u2014\u2014\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u7ba1\u7ebf \u9996\u5148\uff0c\u6211\u4eec\u5b9a\u4f4d\u5230\u8fd9\u4e2a\u4f4d\u7f6e\uff1a public class HelloWorld { // .. private void loop() { // .. glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while (!glfwWindowShouldClose(window)) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } // .. } // .. } \u7136\u540e\uff0c\u628a glClearColor(1.0f, 0.0f, 0.0f, 0.0f); \u6539\u4e3a glClearColor(0.0f, 0.0f, 0.0f, 0.0f); \uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u4eae\u778e\u773c\u4e86\u3002 \u63a5\u7740\u5728 glClear \u540e\u6dfb\u52a0\u4e0b\u9762\u51e0\u6761\u8bed\u53e5\uff1a public class HelloWorld { // .. private void loop() { // .. while (!glfwWindowShouldClose(window)) { // .. glBegin(GL_TRIANGLES); // \u5f00\u59cb\u7ed8\u5236\u4e09\u89d2\u5f62 // \u6ce8\u610f\uff1a\u9700\u8981\u9006\u65f6\u9488\u7ed8\u5236 glColor3f(1, 0, 0); // \u7ea2 glVertex2f(0, 1); // \u4e2d\u4e0a glColor3f(0, 1, 0); // \u7eff glVertex2f(-1, -1); // \u5de6\u4e0b glColor3f(0, 0, 1); // \u84dd glVertex2f(1, -1); // \u53f3\u4e0b glEnd(); // \u7ed8\u5236\u7ed3\u675f // .. } // .. } // .. } \u542f\u52a8\u540e\uff0c\u4f1a\u5f97\u5230\u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62\u3002 glColor4f() \u7528\u4e8e\u8bbe\u7f6e\u989c\u8272, \u4ee5OpenGL\u7684RGBA\u6a21\u5f0f glVertex3f() \u8bbe\u7f6e\u9876\u70b9\u4f4d\u7f6e, \u4ee5x, y, z\u7684\u683c\u5f0f\u3002 \u4e5f\u8bb8\u4f60\u4f1a\u7591\u60d1: \u8fd9\u4e0d\u662f2d\u6e38\u620f\u5417\uff1fz\u8f74\u6709\u4ec0\u4e48\u7528 \u7b54\u6848\u7b80\u5355\u81f3\u6781\uff1a\u5c06\u80cc\u666f\u7684z\u8f74\u53d8\u6df1\uff0c\u4ee5\u4f7f\u5176\u4ed6\u7269\u4f53\u8986\u76d6\u4e8e\u80cc\u666f\u4e0a\u3002 \u8bb0\u5f97\u5f00\u6df1\u5ea6\u6d4b\u8bd5 \u5931\u8d25\u4e86\uff1f\u8fd8\u4e0d\u5feb\u629b issue !","title":"\u4f60\u597d\uff0c\u4e09\u89d2\u5f62"},{"location":"chapter2/hello_window/","text":"\u4f60\u597d\uff0c\u7a97\u53e3\uff01 \u6211\u4eec\u5df2\u7ecf\u914d\u7f6e\u597d\u4e86\u73af\u5883\uff0c\u73b0\u5728\u6765\u521b\u5efa\u4e00\u4e2a\u7a97\u53e3\u3002 \u53ea\u9700\u6839\u636e LWJGL\u5b98\u65b9\u7ed9\u51fa\u7684\u793a\u4f8b\u5373\u53ef . \u5728\u542f\u52a8\u540e\uff0c\u60a8\u5c06\u4f1a\u770b\u5230\u4e00\u4e2a\u7ea2\u8272\u7a97\u53e3\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 GLFW \u4f5c\u4e3aGUI\u5e93\u3002 \u6211\u76f8\u4fe1\u4f60\u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u5bf9\u793a\u4f8b\u611f\u5230\u8d39\u89e3: What's this? \u800c\u4e14\u8fd9\u4e2a\u793a\u4f8b\u4e5f\u592a\u8fc7\u5197\u957f\u4e86 \u8ba9\u6211\u4eec\u6539\u6539 public class HelloWorld { // The window handle private long window; public void run() { System.out.println(\"Hello LWJGL \" + Version.getVersion() + \"!\"); init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(\"Unable to initialize GLFW\"); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default // Create the window window = glfwCreateWindow(300, 300, \"Hello World!\", NULL, NULL); if ( window == NULL ) throw new RuntimeException(\"Failed to create the GLFW window\"); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -> { if ( key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE ) glfwSetWindowShouldClose(window, true); }); // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); } private void loop() { // This line is critical for LWJGL's interoperation with GLFW's // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } public static void main(String[] args) { new HelloWorld().run(); } } \u8ba9\u6211\u4eec\u4ece\u5934\u5f00\u59cb\u8bb2\u89e3\u5427 private long window; \u6211TM\u4e3a\u4ec0\u4e48\u9700\u8981\u5b83\uff1f \u7a97\u53e3\u53e5\u67c4\u3002 \u8fd9\u662f\u7b54\u6848\u3002 \u4f60\u5fc5\u987b\u5f97\u77e5\u9053\uff0cGLFW\u662f\u4e00\u4e2aC\u5e93 C\u8bed\u8a00\u3002\u3002\u3002 \u54e6\u6211\u7684\u4e0a\u5e1d\uff01\u4ed6\u7adf\u7136\u4e0d\u652f\u6301\u7c7b\uff01\uff01\uff01 ~~\u8fd9\u53ef\u771f\u662f\u89c1\u4e86\u9b3c\u4e86~~ \u806a\u660e\u7684\u4eba\u4eec\u60f3\u5230\uff1a \u6211\u7528\u4e00\u4e2a\u6307\u5411\u8fd9\u4e2a\u7a97\u53e3\u4fe1\u606f\u5730\u5740\u7684\u53d8\u91cf\u6765\u6307\u4ee3\u5b83 \u4e0d\u5c31\u5f97\u4e86\uff1f\uff01 \u8fd9\u5c31\u662f\uff1a \u6307\u9488 \u4f46\u662f,Java\u5e76\u4e0d\u652f\u6301\u6307\u9488 \u5e78\u597d\u6307\u9488\u4e5f\u7b97\u662f\u4e2a\u6570\u5b57 \u4eba\u4eec\u5c31\u7528 long \u6765\u66ff\u4ee3\u5b83 \u7136\u540e\u662finit()\u51fd\u6570 GLFWErrorCallback.createPrint(System.err).set(); Setup an error callback. The default implementation will print the error message in System.err. \u7ffb\u8bd1\uff1a \u8bbe\u7f6e\u4e00\u4e2a\u9519\u8bef\u56de\u8c03\u3002\u9ed8\u8ba4\u5b9e\u73b0\u4f1a\u5728System.err\u6d41\u4e2d\u6253\u5370\u4e00\u4e2a\u9519\u8bef\u6d88\u606f \u6709\u70b9\u50cf \u5f02\u5e38 if ( !glfwInit() ) throw new IllegalStateException(\"Unable to initialize GLFW\"); glfwInit() \u4f1a\u521d\u59cb\u5316glfw,\u8fd4\u56de\u662f\u5426\u6210\u529f\u521d\u59cb\u5316 glfwDefaultWindowHints(); \u4f7f\u7528\u9ed8\u8ba4\u7684\u914d\u7f6e \u540c\u65f6\uff0c\u4e5f\u8981\u63d0\u53ca glfwWindowHint(); \u5b83\u7528\u4e8e\u8bbe\u7f6e\u914d\u7f6e glfwSetKeyCallback(); Setup a key callback. It will be called every time a key is pressed, repeated or released. \u7ffb\u8bd1\uff1a \u8bbe\u7f6e\u4e00\u4e2a\u6309\u952e\u56de\u8c03, \u6bcf\u6b21\u6309\u4e0b\u3001\u91cd\u590d\u6216\u91ca\u653e\u67d0\u4e2a\u952e\u65f6\u90fd\u4f1a\u8c03\u7528\u5b83\u3002 \u800c glfwSetWindowShouldClose(window, true); \u5219\u4f1a\u8ba9\u7a97\u53e3\u5173\u95ed glfwMakeContextCurrent(window); \u8bbe\u7f6eOpenGL\u4e0a\u4e0b\u6587 glfwSwapInterval(1); \u5f00\u542f\u5782\u76f4\u540c\u6b65 \u7136\u540e\u662f loop() \u51fd\u6570 GL.createCapabilities(); \u521b\u5efaOpenGL\u4e0a\u4e0b\u6587 Stop... glfwMakeContextCurrent(window); \u8bbe\u7f6eOpenGL\u4e0a\u4e0b\u6587 WTF? \u522b\u6025\u3002\u3002\u3002 This line is critical for LWJGL's interoperation with GLFW's OpenGL context, or any context that is managed externally. LWJGL detects the context that is current in the current thread, creates the GLCapabilities instance and makes the OpenGL bindings available for use. \u7ffb\u8bd1\uff1a \u8fd9\u4e00\u884c\u5bf9\u4e8eLWJGL\u4e0eGLFW\u7684OpenGL\u4e0a\u4e0b\u6587\u6216\u4efb\u4f55\u5916\u90e8\u7ba1\u7406\u7684\u4e0a\u4e0b\u6587\u7684\u64cd\u4f5c\u662f\u81f3\u5173\u91cd\u8981\u7684. LWJGL\u68c0\u6d4b\u5f53\u524d\u7ebf\u7a0b\u4e2d\u7684\u5f53\u524d\u4e0a\u4e0b\u6587\uff0c\u521b\u5efaGLCapabilities\u5b9e\u4f8b\u5e76\u4f7fOpenGL\u7ed1\u5b9a\u53ef\u7528 \u8a00\u7b80\u6613\u8d45 LWJGL\u7279\u6027 glClearColor(1.0f, 0.0f, 0.0f, 0.0f); \u8bbe\u7f6e\u80cc\u666f\u8272\uff0c \u4ee5RGBA\u6a21\u5f0f OpenGL\u7684RGBA\u4e0e\u666e\u901a\u7684\u8f6c\u6362\u5173\u7cfb\u5982\u4e0b public OpenGLRGBA toOpenGL(RGBA color) { OpenGLRGBA rgba; rgba.r = (float) color.r / 256.0f; rgba.g = (float) color.g / 256.0f; rgba.b = (float) color.b / 256.0f; rgba.a = (float) color.a / 256.0f; } glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \u6e05\u9664\u989c\u8272\u7f13\u51b2\u548c\u6df1\u5ea6\u7f13\u51b2 glfwSwapBuffers(window); \u4ea4\u6362\u7f13\u51b2 OpenGL\u7684\u53cc\u7f13\u51b2 \u4e3a\u4e86\u4fdd\u969c\u4f53\u9a8c\uff0cOpenGL\u7528\u4e24\u4e2a\u7f13\u51b2\u8f6e\u6d41\u5de5\u4f5c \u4e00\u4e2a\u5728\u53f0\u524d\u5531\u620f \u4e00\u4e2a\u5728\u5e55\u540e\u5316\u5986 \u5f53 glfwSwapBuffers() \u88ab\u8c03\u7528\u65f6 \u4e24\u4e2a\u7f13\u51b2\u5c31\u4f1a\u4ea4\u6362\u4f4d\u7f6e \u4f60\u80af\u5b9a\u4e0d\u5e0c\u671b\u770b\u5230\u4e00\u4e2a\u6f14\u5458\u8fb9\u5316\u5986\u8fb9\u5531\u620f\u5427 glfwPollEvents(); \u8ba9GLFW\u6309\u60c5\u51b5\u89e6\u53d1\u4e8b\u4ef6 // \u6e05\u7a7a\u56de\u8c03 glfwFreeCallbacks(window); // \u5173\u95ed\uff08\u5220\u9664\uff09\u7a97\u53e3 glfwDestroyWindow(window); // \u91ca\u653e\u5185\u5b58 glfwTerminate(); // \u91ca\u653e\u9519\u8bef\u56de\u8c03 glfwSetErrorCallback(null).free(); Nice~","title":"\u4f60\u597d\uff0c\u7a97\u53e3\uff01"},{"location":"chapter2/hello_window/#_1","text":"\u6211\u4eec\u5df2\u7ecf\u914d\u7f6e\u597d\u4e86\u73af\u5883\uff0c\u73b0\u5728\u6765\u521b\u5efa\u4e00\u4e2a\u7a97\u53e3\u3002 \u53ea\u9700\u6839\u636e LWJGL\u5b98\u65b9\u7ed9\u51fa\u7684\u793a\u4f8b\u5373\u53ef . \u5728\u542f\u52a8\u540e\uff0c\u60a8\u5c06\u4f1a\u770b\u5230\u4e00\u4e2a\u7ea2\u8272\u7a97\u53e3\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u4e86 GLFW \u4f5c\u4e3aGUI\u5e93\u3002 \u6211\u76f8\u4fe1\u4f60\u65e0\u8bba\u5982\u4f55\u90fd\u4f1a\u5bf9\u793a\u4f8b\u611f\u5230\u8d39\u89e3: What's this? \u800c\u4e14\u8fd9\u4e2a\u793a\u4f8b\u4e5f\u592a\u8fc7\u5197\u957f\u4e86 \u8ba9\u6211\u4eec\u6539\u6539 public class HelloWorld { // The window handle private long window; public void run() { System.out.println(\"Hello LWJGL \" + Version.getVersion() + \"!\"); init(); loop(); // Free the window callbacks and destroy the window glfwFreeCallbacks(window); glfwDestroyWindow(window); // Terminate GLFW and free the error callback glfwTerminate(); glfwSetErrorCallback(null).free(); } private void init() { // Setup an error callback. The default implementation // will print the error message in System.err. GLFWErrorCallback.createPrint(System.err).set(); // Initialize GLFW. Most GLFW functions will not work before doing this. if ( !glfwInit() ) throw new IllegalStateException(\"Unable to initialize GLFW\"); // Configure GLFW glfwDefaultWindowHints(); // optional, the current window hints are already the default // Create the window window = glfwCreateWindow(300, 300, \"Hello World!\", NULL, NULL); if ( window == NULL ) throw new RuntimeException(\"Failed to create the GLFW window\"); // Setup a key callback. It will be called every time a key is pressed, repeated or released. glfwSetKeyCallback(window, (window, key, scancode, action, mods) -> { if ( key == GLFW_KEY_ESCAPE && action == GLFW_RELEASE ) glfwSetWindowShouldClose(window, true); }); // Make the OpenGL context current glfwMakeContextCurrent(window); // Enable v-sync glfwSwapInterval(1); } private void loop() { // This line is critical for LWJGL's interoperation with GLFW's // OpenGL context, or any context that is managed externally. // LWJGL detects the context that is current in the current thread, // creates the GLCapabilities instance and makes the OpenGL // bindings available for use. GL.createCapabilities(); // Set the clear color glClearColor(1.0f, 0.0f, 0.0f, 0.0f); // Run the rendering loop until the user has attempted to close // the window or has pressed the ESCAPE key. while ( !glfwWindowShouldClose(window) ) { glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // clear the framebuffer glfwSwapBuffers(window); // swap the color buffers // Poll for window events. The key callback above will only be // invoked during this call. glfwPollEvents(); } } public static void main(String[] args) { new HelloWorld().run(); } } \u8ba9\u6211\u4eec\u4ece\u5934\u5f00\u59cb\u8bb2\u89e3\u5427 private long window; \u6211TM\u4e3a\u4ec0\u4e48\u9700\u8981\u5b83\uff1f \u7a97\u53e3\u53e5\u67c4\u3002 \u8fd9\u662f\u7b54\u6848\u3002 \u4f60\u5fc5\u987b\u5f97\u77e5\u9053\uff0cGLFW\u662f\u4e00\u4e2aC\u5e93 C\u8bed\u8a00\u3002\u3002\u3002 \u54e6\u6211\u7684\u4e0a\u5e1d\uff01\u4ed6\u7adf\u7136\u4e0d\u652f\u6301\u7c7b\uff01\uff01\uff01 ~~\u8fd9\u53ef\u771f\u662f\u89c1\u4e86\u9b3c\u4e86~~ \u806a\u660e\u7684\u4eba\u4eec\u60f3\u5230\uff1a \u6211\u7528\u4e00\u4e2a\u6307\u5411\u8fd9\u4e2a\u7a97\u53e3\u4fe1\u606f\u5730\u5740\u7684\u53d8\u91cf\u6765\u6307\u4ee3\u5b83 \u4e0d\u5c31\u5f97\u4e86\uff1f\uff01 \u8fd9\u5c31\u662f\uff1a \u6307\u9488 \u4f46\u662f,Java\u5e76\u4e0d\u652f\u6301\u6307\u9488 \u5e78\u597d\u6307\u9488\u4e5f\u7b97\u662f\u4e2a\u6570\u5b57 \u4eba\u4eec\u5c31\u7528 long \u6765\u66ff\u4ee3\u5b83 \u7136\u540e\u662finit()\u51fd\u6570 GLFWErrorCallback.createPrint(System.err).set(); Setup an error callback. The default implementation will print the error message in System.err. \u7ffb\u8bd1\uff1a \u8bbe\u7f6e\u4e00\u4e2a\u9519\u8bef\u56de\u8c03\u3002\u9ed8\u8ba4\u5b9e\u73b0\u4f1a\u5728System.err\u6d41\u4e2d\u6253\u5370\u4e00\u4e2a\u9519\u8bef\u6d88\u606f \u6709\u70b9\u50cf \u5f02\u5e38 if ( !glfwInit() ) throw new IllegalStateException(\"Unable to initialize GLFW\"); glfwInit() \u4f1a\u521d\u59cb\u5316glfw,\u8fd4\u56de\u662f\u5426\u6210\u529f\u521d\u59cb\u5316 glfwDefaultWindowHints(); \u4f7f\u7528\u9ed8\u8ba4\u7684\u914d\u7f6e \u540c\u65f6\uff0c\u4e5f\u8981\u63d0\u53ca glfwWindowHint(); \u5b83\u7528\u4e8e\u8bbe\u7f6e\u914d\u7f6e glfwSetKeyCallback(); Setup a key callback. It will be called every time a key is pressed, repeated or released. \u7ffb\u8bd1\uff1a \u8bbe\u7f6e\u4e00\u4e2a\u6309\u952e\u56de\u8c03, \u6bcf\u6b21\u6309\u4e0b\u3001\u91cd\u590d\u6216\u91ca\u653e\u67d0\u4e2a\u952e\u65f6\u90fd\u4f1a\u8c03\u7528\u5b83\u3002 \u800c glfwSetWindowShouldClose(window, true); \u5219\u4f1a\u8ba9\u7a97\u53e3\u5173\u95ed glfwMakeContextCurrent(window); \u8bbe\u7f6eOpenGL\u4e0a\u4e0b\u6587 glfwSwapInterval(1); \u5f00\u542f\u5782\u76f4\u540c\u6b65 \u7136\u540e\u662f loop() \u51fd\u6570 GL.createCapabilities(); \u521b\u5efaOpenGL\u4e0a\u4e0b\u6587 Stop... glfwMakeContextCurrent(window); \u8bbe\u7f6eOpenGL\u4e0a\u4e0b\u6587 WTF? \u522b\u6025\u3002\u3002\u3002 This line is critical for LWJGL's interoperation with GLFW's OpenGL context, or any context that is managed externally. LWJGL detects the context that is current in the current thread, creates the GLCapabilities instance and makes the OpenGL bindings available for use. \u7ffb\u8bd1\uff1a \u8fd9\u4e00\u884c\u5bf9\u4e8eLWJGL\u4e0eGLFW\u7684OpenGL\u4e0a\u4e0b\u6587\u6216\u4efb\u4f55\u5916\u90e8\u7ba1\u7406\u7684\u4e0a\u4e0b\u6587\u7684\u64cd\u4f5c\u662f\u81f3\u5173\u91cd\u8981\u7684. LWJGL\u68c0\u6d4b\u5f53\u524d\u7ebf\u7a0b\u4e2d\u7684\u5f53\u524d\u4e0a\u4e0b\u6587\uff0c\u521b\u5efaGLCapabilities\u5b9e\u4f8b\u5e76\u4f7fOpenGL\u7ed1\u5b9a\u53ef\u7528 \u8a00\u7b80\u6613\u8d45 LWJGL\u7279\u6027 glClearColor(1.0f, 0.0f, 0.0f, 0.0f); \u8bbe\u7f6e\u80cc\u666f\u8272\uff0c \u4ee5RGBA\u6a21\u5f0f OpenGL\u7684RGBA\u4e0e\u666e\u901a\u7684\u8f6c\u6362\u5173\u7cfb\u5982\u4e0b public OpenGLRGBA toOpenGL(RGBA color) { OpenGLRGBA rgba; rgba.r = (float) color.r / 256.0f; rgba.g = (float) color.g / 256.0f; rgba.b = (float) color.b / 256.0f; rgba.a = (float) color.a / 256.0f; } glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); \u6e05\u9664\u989c\u8272\u7f13\u51b2\u548c\u6df1\u5ea6\u7f13\u51b2 glfwSwapBuffers(window); \u4ea4\u6362\u7f13\u51b2","title":"\u4f60\u597d\uff0c\u7a97\u53e3\uff01"},{"location":"chapter2/hello_window/#opengl","text":"\u4e3a\u4e86\u4fdd\u969c\u4f53\u9a8c\uff0cOpenGL\u7528\u4e24\u4e2a\u7f13\u51b2\u8f6e\u6d41\u5de5\u4f5c \u4e00\u4e2a\u5728\u53f0\u524d\u5531\u620f \u4e00\u4e2a\u5728\u5e55\u540e\u5316\u5986 \u5f53 glfwSwapBuffers() \u88ab\u8c03\u7528\u65f6 \u4e24\u4e2a\u7f13\u51b2\u5c31\u4f1a\u4ea4\u6362\u4f4d\u7f6e \u4f60\u80af\u5b9a\u4e0d\u5e0c\u671b\u770b\u5230\u4e00\u4e2a\u6f14\u5458\u8fb9\u5316\u5986\u8fb9\u5531\u620f\u5427 glfwPollEvents(); \u8ba9GLFW\u6309\u60c5\u51b5\u89e6\u53d1\u4e8b\u4ef6 // \u6e05\u7a7a\u56de\u8c03 glfwFreeCallbacks(window); // \u5173\u95ed\uff08\u5220\u9664\uff09\u7a97\u53e3 glfwDestroyWindow(window); // \u91ca\u653e\u5185\u5b58 glfwTerminate(); // \u91ca\u653e\u9519\u8bef\u56de\u8c03 glfwSetErrorCallback(null).free(); Nice~","title":"OpenGL\u7684\u53cc\u7f13\u51b2"},{"location":"chapter2/shader/","text":"\u7740\u8272\u5668\uff08\u4e0a\uff09 \u672c\u8282\u7684\u6e90\u7801\u53ef\u5728 root \u4e2d\u627e\u5230\u3002 \u5728\u5f00\u59cb\u524d\uff0c\u6211\u4eec\u5148\u5217\u51fa\u60f3\u8981\u5b9e\u73b0\u7684\u529f\u80fd\u3002 \u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62 \u53ef\u4ee5\u79fb\u52a8\uff08\u7c7b\u4f3c\u4e8e glTranslate* \uff09 \u53ef\u4ee5\u7f29\u653e\uff08\u7c7b\u4f3c\u4e8e glScale* \uff09 \u53ef\u4ee5\u65cb\u8f6c\uff08\u7c7b\u4f3c\u4e8e glRotate* \uff09 \u73b0\u5728\u53ef\u4ee5\u5f00\u5de5\u4e86\u3002 \u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62 \u5728\u5f00\u59cb\u524d\uff0c\u6211\u4eec\u5148\u628a\u4ee3\u7801\u6574\u7406\u4e0b\uff08\u4e71\u7cdf\u7cdf\u7684\u4ee3\u7801\u603b\u662f\u4e0d\u597d)\u3002\u4e0d\u7ed9\u51fa\u592a\u591a\u7684\u5b9e\u73b0\uff0c\u5982\u679c\u9700\u8981\u8be6\u7ec6\u4fe1\u606f\u8bf7\u67e5\u770b\u6e90\u7801\u3002 \u9996\u5148\u521b\u5efa\u4e00\u4e2a\u63a5\u53e3\u3002\u8be5\u63a5\u53e3\u5305\u542b\u6e38\u620f\u903b\u8f91\u3002 public interface IGameLogic { void init(); void input(Window window); void update(float delta); void render(int mouseX, int mouseY); } \u518d\u521b\u5efa\u4e00\u4e2aWindow\u7c7b\uff1a public final class Window { private final String title; private int width, height; private long handle; private boolean resized; public Window(String title, int width, int height); public void init(); public boolean isKeyPressed(int key); public boolean shouldClose(); public void update(); public String getTitle(); public int getWidth(); public int getHeight(); public boolean isResized(); public void setResized(boolean resized); } \u7136\u540e\u628aGLFW\u521d\u59cb\u5316\u4ee3\u7801\u653e\u5230 Window \u7c7b\u4e0b\u3002 \u4e3a\u4e86\u65b9\u4fbf \u5077\u61d2 \uff0c\u6211\u4eec\u4f7f\u7528\u7531\u6211\u4eec\u63a8\u51fa\u7684GLUtils\u6765\u5e2e\u52a9\u6211\u4eec\u3002 \u4fee\u6539 build.gradle \uff1a dependencies { implementation \"io.github.over-run:glutils:0.3.0\" } \u4e4b\u540e\u521b\u5efa\u4e00\u4e2a GameRenderer \u8d1f\u8d23\u6e32\u67d3\u3002 public final class GameRenderer { public void init(); public void render(); } \u6700\u540e\u6211\u4eec\u521b\u5efa DummyGame \u6765\u5b9e\u73b0 IGameLogic \uff0c\u5e76\u7531 GameEngine \u6258\u7ba1\u3002 public final class DummyGame implements IGameLogic { private final GameRenderer renderer = new GameRenderer(); @Override public void init(); @Override public void input(Window window); @Override public void update(float delta); @Override public void render(Window window); } public final class GameEngine implements Runnable { private final Window window; private final IGameLogic logic; private final Timer timer = new Timer(); public GameEngine(String title, int width, int height, IGameLogic logic); public void init(); public void input(); public void update(float delta); public void render(); private void loop(); @Override public void run(); } \u6253\u5f00\u540e\uff0c\u4f60\u5c31\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u65e0\u804a\u7684\u9ed1\u8272\u7a97\u53e3\u4e86\u3002 \u7f16\u5199\u7740\u8272\u5668 \u4e3a\u4e86\u4e0d\u4f7f\u7528\u56fa\u5b9a\u7ba1\u7ebf\u800c\u5728\u7a97\u53e3\u4e2d\u663e\u793a\u56fe\u50cf\uff0c\u6211\u4eec\u9700\u8981\u81f3\u5c112\u4e2a\u7740\u8272\u5668\uff1a\u9876\u70b9\u7740\u8272\u5668(vertex shader(vsh))\u548c\u7247\u5143\u7740\u8272\u5668(fragment shader(fsh))\u3002 \u5f53\u7136\uff0c\u4f60\u8fd8\u4f1a\u9047\u5230\u51e0\u4f55\u7740\u8272\u5668(geomety shader(gsh))\u3002 vsh\u793a\u4f8b\u5f88\u7b80\u5355\uff1a (item.vsh) #version 110 in vec2 vert; void main() { gl_Position = vec4(vert, 0, 1); } fsh\u4e5f\u7c7b\u4f3c\uff1a (item.fsh) #version 110 void main() { gl_FragColor = vec4(1, 0, 0, 1); } #version 110 \u4ee3\u8868\u4e86\u7740\u8272\u5668\u7684\u7248\u672c\uff08\u6b64\u5904\u4e3aGLSL 1.1) in vec2 vert; \u4ee3\u8868\u8f93\u5165\u4e00\u4e2a\u4e8c\u7ef4\u5411\u91cfvert\uff0c \u5373\u9876\u70b9\u4f4d\u7f6e void main() \u662f\u7740\u8272\u5668\u7a0b\u5e8f\u7684\u5165\u53e3\u3002\u4e0eC\u4e0d\u540c\uff0c\u8fd9\u91cc\u7684 main \u4e0d\u9700\u8981\u8fd4\u56de\u503c\u3002 gl_Position \u662f\u4e00\u4e2a\u7279\u6b8a\u53d8\u91cf\uff0cOpenGL\u4f1a\u4ece\u8fd9\u91cc\u8bfb\u53d6\u9876\u70b9\u4f4d\u7f6e gl_FragColor \u662f\u4e00\u4e2a\u7279\u6b8a\u53d8\u91cf\uff0cOpenGL\u4f1a\u4ece\u8fd9\u91cc\u8bfb\u53d6\u7247\u6bb5\u989c\u8272 \u4ee5\u4e0a\u7740\u8272\u5668\u5c06\u5728 vert.x, vert.y \u5904\u663e\u793a\u4e00\u4e2a\u7ea2\u8272\u7684\u56fe\u5f62\u3002 \u663e\u7136\uff0c\u6211\u4eec\u9700\u8981\u8bfb\u53d6\u7740\u8272\u5668\u5e76\u8ba9OpenGL\u8bc6\u522b\u5b83 \u5e9f\u8bdd \u7531\u4e8eGLUtils\u7684\u5f15\u5165\uff0c\u8fd9\u91cc\u4e00\u5927\u6bb5\u88ab\u5220\u4e86\u3002 \u9996\u5148\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u3002 #version 110 attribute vec2 vert; attribute vec3 in_color; varying vec3 out_color; void main() { gl_Position = vec4(vert, 0, 1); out_color = in_color; } \u8fd9\u6837\u53ef\u4ee5\u8bbe\u7f6e\u989c\u8272\u3002 \u7136\u540e\u4fee\u6539\u7247\u5143\u7740\u8272\u5668\u3002 #version 110 varying vec3 out_color; void main() { gl_FragColor = vec4(out_color, 1); } \u73b0\u5728\u53ef\u4ee5\u5bf9 GameRenderer \u8fdb\u884c\u4fee\u6539\u4e86\u3002 \u6211\u4eec\u5728\u6e32\u67d3\u5668\u4e2d\u521d\u59cb\u5316\u4e86\u6211\u4eec\u7684 program\uff0c\u5e76\u4e14\u4f7f\u7528\u5b83\u3002 \u5b8c\u6210\u4e86\u5417\uff1f \u5f53\u7136\u6ca1\u6709\u3002\u6211\u4eec\u8fd8\u6709vbo\u548cvao\u6ca1\u5199\u5462\u3002 \u7531\u4e8e\u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4f7f\u7528 OpenGL 2.0\uff0c \u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684 vao(0)\u3002 \u6211\u4eec\u5c06\u5728 link the program \u540e\u5bf9 vbo \u8fdb\u884c\u521d\u59cb\u5316\u3002 \u9996\u5148\u6211\u4eec\u9700\u8981\u4e00\u4efd\u9876\u70b9\u4f4d\u7f6e\u7684\u6570\u7ec4\u3002\u7531\u4e8e\u8fd9\u662f\u4e2a\u4e09\u89d2\u5f62\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u89812\u00d73\u4e2a\u9876\u70b9\u3002 float[] vertices = { // \u4e2d\u4e0a 0, .5f, // \u5de6\u4e0b -.5f, -.5f, // \u53f3\u4e0b .5f, -.5f }; \u63a5\u7740\u6211\u4eec\u5c06\u4f7f\u7528 glGenBuffers \u751f\u6210 vbo\u3002 \u7136\u540e\u6211\u4eec\u4f7f\u7528 glBindBuffer(GL_ARRAY_BUFFER, vertVbo) \u5c06\u5176\u7ed1\u5b9a\u5230 GL_ARRAY_BUFFER \u4e0a\u3002 \u5bf9 colorVbo \u4e5f\u6267\u884c\u540c\u6837\u7684\u64cd\u4f5c\u3002 \u542f\u52a8\u540e\uff0c\u53c8\u4f1a\u5f97\u5230\u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62\u3002 \u77e9\u9635\u53d8\u6362 \u5728\u5b9e\u73b0\u79fb\u52a8\u524d\uff0c\u6211\u4eec\u5148\u60f3\u529e\u6cd5\u5c06OpenGL\u5750\u6807\u7cfb(-1.0\u223c1)\u8f6c\u4e3a\u5c4f\u5e55\u5750\u6807\u7cfb(0\u223cw,0\u223ch)\u3002 \u6211\u4eec\u5c06\u521b\u5efa\u4e00\u4e2a\u53d8\u6362\u7c7b\u3002\u5b83\u5305\u542b\u4e00\u4e2a\u6295\u5f71\u77e9\u9635\u3002\u5e76\u5728\u4f7f\u7528\u65f6\u4f20\u5165\u65b9\u5757\u4ee5\u53ca\u5c4f\u5e55\u5bbd\u9ad8\u3002 public final class Transformation { private final Matrix4f orthoMatrix = new Matrix4f(); public Matrix4f getOrthoMatrix(Block block, float w, float h) { return orthoMatrix.identity() .ortho2D(0, w, h, 0) .translate(block.x, block.y, 0) .rotateZ(block.rotation) .scaleXY(block.scale, block.scale); } } \u53ef\u4ee5\u770b\u5230\uff0c\u8fd9\u548c\u6211\u4eec\u7684\u4f20\u7edf\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002 glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(0, w, h, 0, 1, -1); glMatrixMode(GL_MODELVIEW); glTranslatef(block.x, block.y, 0); glRotatef(block.rotation, 0, 0, 1); glScalef(block.scale, block.scale, 0); \u5728\u5b8c\u6210\u540e\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u3002 #version 110 attribute vec2 vert; attribute vec3 in_color; varying vec3 out_color; // \u4f60\u53ef\u4ee5\u770b\u5230\u6211\u4eec\u6dfb\u52a0\u4e86\u4e00\u4e2a\u77e9\u9635\u3002 uniform mat4 orthoMatrix; void main() { // \u8be5\u77e9\u9635\u5c06\u5bf9vert\u8fdb\u884c\u4e58\u6cd5\u64cd\u4f5c\u3002 gl_Position = orthoMatrix * vec4(vert, 0, 1); out_color = in_color; } \u73b0\u5728\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002\u6211\u4eec\u5728 GameRenderer \u4e2d\u5b9e\u4f8b\u5316\u6211\u4eec\u7684 Transformation \uff0c\u5e76\u5728\u6e32\u67d3\u65f6\u83b7\u53d6\u77e9\u9635\u3002 \u6211\u4eec\u8fd8\u9700\u8981\u4fee\u6539\u9876\u70b9\u4f4d\u7f6e\u4ee5\u5bf9\u5e94\u5c4f\u5e55\u5750\u6807\u7cfb\u3002 float[] vertices = { // \u5de6\u4e0a 0, 0, // \u5de6\u4e0b 0, 256, // \u53f3\u4e0b 256, 256, }; \u6211\u4eec\u5c06\u5728 program#bind \u4e4b\u540e\u8bbe\u7f6e uniform \u3002 try (MemoryStack stack = MemoryStack.stackPush()) { glUniformMatrix4fv(program.getUniform(\"orthoMatrix\"), false, transformation.getOrthoMatrix(block, window.getWidth(), window.getHeight()) .get(stack.mallocFloat(16))); } \u4e00\u5207\u51c6\u5907\u5c31\u7eea\u3002 \u5750\u548c\u653e\u5bbd\u3002 \u6211\u4eec\u53ea\u9700\u8981\u5904\u7406\u952e\u76d8\u8f93\u5165\u5373\u53ef\u6d4b\u8bd5\u4e09\u89d2\u5f62\u7684\u79fb\u52a8\u3001\u65cb\u8f6c\u548c\u7f29\u653e\u3002 \u6211\u4eec\u5c06\u770b\u5230\u4e0b\u56fe\uff1a \u5728\u793a\u4f8b\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u90e8\u5206\u5b9e\u73b0\u4e86 \u6444\u50cf\u673a \u7684\u529f\u80fd\u3002\u53ea\u662f\u6211\u4eec\u6309\u4e0b\u952e\u76d8\u65f6\u4f1a\u628a\u4e09\u89d2\u5f62\u7684\u5750\u6807\u6539\u53d8\u3002","title":"\u7740\u8272\u5668"},{"location":"chapter2/shader/#_1","text":"\u672c\u8282\u7684\u6e90\u7801\u53ef\u5728 root \u4e2d\u627e\u5230\u3002 \u5728\u5f00\u59cb\u524d\uff0c\u6211\u4eec\u5148\u5217\u51fa\u60f3\u8981\u5b9e\u73b0\u7684\u529f\u80fd\u3002 \u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62 \u53ef\u4ee5\u79fb\u52a8\uff08\u7c7b\u4f3c\u4e8e glTranslate* \uff09 \u53ef\u4ee5\u7f29\u653e\uff08\u7c7b\u4f3c\u4e8e glScale* \uff09 \u53ef\u4ee5\u65cb\u8f6c\uff08\u7c7b\u4f3c\u4e8e glRotate* \uff09 \u73b0\u5728\u53ef\u4ee5\u5f00\u5de5\u4e86\u3002","title":"\u7740\u8272\u5668\uff08\u4e0a\uff09"},{"location":"chapter2/shader/#_2","text":"\u5728\u5f00\u59cb\u524d\uff0c\u6211\u4eec\u5148\u628a\u4ee3\u7801\u6574\u7406\u4e0b\uff08\u4e71\u7cdf\u7cdf\u7684\u4ee3\u7801\u603b\u662f\u4e0d\u597d)\u3002\u4e0d\u7ed9\u51fa\u592a\u591a\u7684\u5b9e\u73b0\uff0c\u5982\u679c\u9700\u8981\u8be6\u7ec6\u4fe1\u606f\u8bf7\u67e5\u770b\u6e90\u7801\u3002 \u9996\u5148\u521b\u5efa\u4e00\u4e2a\u63a5\u53e3\u3002\u8be5\u63a5\u53e3\u5305\u542b\u6e38\u620f\u903b\u8f91\u3002 public interface IGameLogic { void init(); void input(Window window); void update(float delta); void render(int mouseX, int mouseY); } \u518d\u521b\u5efa\u4e00\u4e2aWindow\u7c7b\uff1a public final class Window { private final String title; private int width, height; private long handle; private boolean resized; public Window(String title, int width, int height); public void init(); public boolean isKeyPressed(int key); public boolean shouldClose(); public void update(); public String getTitle(); public int getWidth(); public int getHeight(); public boolean isResized(); public void setResized(boolean resized); } \u7136\u540e\u628aGLFW\u521d\u59cb\u5316\u4ee3\u7801\u653e\u5230 Window \u7c7b\u4e0b\u3002 \u4e3a\u4e86\u65b9\u4fbf \u5077\u61d2 \uff0c\u6211\u4eec\u4f7f\u7528\u7531\u6211\u4eec\u63a8\u51fa\u7684GLUtils\u6765\u5e2e\u52a9\u6211\u4eec\u3002 \u4fee\u6539 build.gradle \uff1a dependencies { implementation \"io.github.over-run:glutils:0.3.0\" } \u4e4b\u540e\u521b\u5efa\u4e00\u4e2a GameRenderer \u8d1f\u8d23\u6e32\u67d3\u3002 public final class GameRenderer { public void init(); public void render(); } \u6700\u540e\u6211\u4eec\u521b\u5efa DummyGame \u6765\u5b9e\u73b0 IGameLogic \uff0c\u5e76\u7531 GameEngine \u6258\u7ba1\u3002 public final class DummyGame implements IGameLogic { private final GameRenderer renderer = new GameRenderer(); @Override public void init(); @Override public void input(Window window); @Override public void update(float delta); @Override public void render(Window window); } public final class GameEngine implements Runnable { private final Window window; private final IGameLogic logic; private final Timer timer = new Timer(); public GameEngine(String title, int width, int height, IGameLogic logic); public void init(); public void input(); public void update(float delta); public void render(); private void loop(); @Override public void run(); } \u6253\u5f00\u540e\uff0c\u4f60\u5c31\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u65e0\u804a\u7684\u9ed1\u8272\u7a97\u53e3\u4e86\u3002","title":"\u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62"},{"location":"chapter2/shader/#_3","text":"\u4e3a\u4e86\u4e0d\u4f7f\u7528\u56fa\u5b9a\u7ba1\u7ebf\u800c\u5728\u7a97\u53e3\u4e2d\u663e\u793a\u56fe\u50cf\uff0c\u6211\u4eec\u9700\u8981\u81f3\u5c112\u4e2a\u7740\u8272\u5668\uff1a\u9876\u70b9\u7740\u8272\u5668(vertex shader(vsh))\u548c\u7247\u5143\u7740\u8272\u5668(fragment shader(fsh))\u3002 \u5f53\u7136\uff0c\u4f60\u8fd8\u4f1a\u9047\u5230\u51e0\u4f55\u7740\u8272\u5668(geomety shader(gsh))\u3002 vsh\u793a\u4f8b\u5f88\u7b80\u5355\uff1a (item.vsh) #version 110 in vec2 vert; void main() { gl_Position = vec4(vert, 0, 1); } fsh\u4e5f\u7c7b\u4f3c\uff1a (item.fsh) #version 110 void main() { gl_FragColor = vec4(1, 0, 0, 1); } #version 110 \u4ee3\u8868\u4e86\u7740\u8272\u5668\u7684\u7248\u672c\uff08\u6b64\u5904\u4e3aGLSL 1.1) in vec2 vert; \u4ee3\u8868\u8f93\u5165\u4e00\u4e2a\u4e8c\u7ef4\u5411\u91cfvert\uff0c \u5373\u9876\u70b9\u4f4d\u7f6e void main() \u662f\u7740\u8272\u5668\u7a0b\u5e8f\u7684\u5165\u53e3\u3002\u4e0eC\u4e0d\u540c\uff0c\u8fd9\u91cc\u7684 main \u4e0d\u9700\u8981\u8fd4\u56de\u503c\u3002 gl_Position \u662f\u4e00\u4e2a\u7279\u6b8a\u53d8\u91cf\uff0cOpenGL\u4f1a\u4ece\u8fd9\u91cc\u8bfb\u53d6\u9876\u70b9\u4f4d\u7f6e gl_FragColor \u662f\u4e00\u4e2a\u7279\u6b8a\u53d8\u91cf\uff0cOpenGL\u4f1a\u4ece\u8fd9\u91cc\u8bfb\u53d6\u7247\u6bb5\u989c\u8272 \u4ee5\u4e0a\u7740\u8272\u5668\u5c06\u5728 vert.x, vert.y \u5904\u663e\u793a\u4e00\u4e2a\u7ea2\u8272\u7684\u56fe\u5f62\u3002 \u663e\u7136\uff0c\u6211\u4eec\u9700\u8981\u8bfb\u53d6\u7740\u8272\u5668\u5e76\u8ba9OpenGL\u8bc6\u522b\u5b83 \u5e9f\u8bdd \u7531\u4e8eGLUtils\u7684\u5f15\u5165\uff0c\u8fd9\u91cc\u4e00\u5927\u6bb5\u88ab\u5220\u4e86\u3002 \u9996\u5148\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u3002 #version 110 attribute vec2 vert; attribute vec3 in_color; varying vec3 out_color; void main() { gl_Position = vec4(vert, 0, 1); out_color = in_color; } \u8fd9\u6837\u53ef\u4ee5\u8bbe\u7f6e\u989c\u8272\u3002 \u7136\u540e\u4fee\u6539\u7247\u5143\u7740\u8272\u5668\u3002 #version 110 varying vec3 out_color; void main() { gl_FragColor = vec4(out_color, 1); } \u73b0\u5728\u53ef\u4ee5\u5bf9 GameRenderer \u8fdb\u884c\u4fee\u6539\u4e86\u3002 \u6211\u4eec\u5728\u6e32\u67d3\u5668\u4e2d\u521d\u59cb\u5316\u4e86\u6211\u4eec\u7684 program\uff0c\u5e76\u4e14\u4f7f\u7528\u5b83\u3002 \u5b8c\u6210\u4e86\u5417\uff1f \u5f53\u7136\u6ca1\u6709\u3002\u6211\u4eec\u8fd8\u6709vbo\u548cvao\u6ca1\u5199\u5462\u3002 \u7531\u4e8e\u5728\u672c\u6559\u7a0b\u4e2d\u6211\u4eec\u4f7f\u7528 OpenGL 2.0\uff0c \u6240\u4ee5\u6211\u4eec\u4f7f\u7528\u9ed8\u8ba4\u7684 vao(0)\u3002 \u6211\u4eec\u5c06\u5728 link the program \u540e\u5bf9 vbo \u8fdb\u884c\u521d\u59cb\u5316\u3002 \u9996\u5148\u6211\u4eec\u9700\u8981\u4e00\u4efd\u9876\u70b9\u4f4d\u7f6e\u7684\u6570\u7ec4\u3002\u7531\u4e8e\u8fd9\u662f\u4e2a\u4e09\u89d2\u5f62\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u89812\u00d73\u4e2a\u9876\u70b9\u3002 float[] vertices = { // \u4e2d\u4e0a 0, .5f, // \u5de6\u4e0b -.5f, -.5f, // \u53f3\u4e0b .5f, -.5f }; \u63a5\u7740\u6211\u4eec\u5c06\u4f7f\u7528 glGenBuffers \u751f\u6210 vbo\u3002 \u7136\u540e\u6211\u4eec\u4f7f\u7528 glBindBuffer(GL_ARRAY_BUFFER, vertVbo) \u5c06\u5176\u7ed1\u5b9a\u5230 GL_ARRAY_BUFFER \u4e0a\u3002 \u5bf9 colorVbo \u4e5f\u6267\u884c\u540c\u6837\u7684\u64cd\u4f5c\u3002 \u542f\u52a8\u540e\uff0c\u53c8\u4f1a\u5f97\u5230\u4e00\u4e2a\u9c9c\u8273\u7684\u4e09\u89d2\u5f62\u3002","title":"\u7f16\u5199\u7740\u8272\u5668"},{"location":"chapter2/shader/#_4","text":"\u5728\u5b9e\u73b0\u79fb\u52a8\u524d\uff0c\u6211\u4eec\u5148\u60f3\u529e\u6cd5\u5c06OpenGL\u5750\u6807\u7cfb(-1.0\u223c1)\u8f6c\u4e3a\u5c4f\u5e55\u5750\u6807\u7cfb(0\u223cw,0\u223ch)\u3002 \u6211\u4eec\u5c06\u521b\u5efa\u4e00\u4e2a\u53d8\u6362\u7c7b\u3002\u5b83\u5305\u542b\u4e00\u4e2a\u6295\u5f71\u77e9\u9635\u3002\u5e76\u5728\u4f7f\u7528\u65f6\u4f20\u5165\u65b9\u5757\u4ee5\u53ca\u5c4f\u5e55\u5bbd\u9ad8\u3002 public final class Transformation { private final Matrix4f orthoMatrix = new Matrix4f(); public Matrix4f getOrthoMatrix(Block block, float w, float h) { return orthoMatrix.identity() .ortho2D(0, w, h, 0) .translate(block.x, block.y, 0) .rotateZ(block.rotation) .scaleXY(block.scale, block.scale); } } \u53ef\u4ee5\u770b\u5230\uff0c\u8fd9\u548c\u6211\u4eec\u7684\u4f20\u7edf\u64cd\u4f5c\u975e\u5e38\u7c7b\u4f3c\u3002 glMatrixMode(GL_PROJECTION); glLoadIdentity(); glOrtho(0, w, h, 0, 1, -1); glMatrixMode(GL_MODELVIEW); glTranslatef(block.x, block.y, 0); glRotatef(block.rotation, 0, 0, 1); glScalef(block.scale, block.scale, 0); \u5728\u5b8c\u6210\u540e\uff0c\u6211\u4eec\u9700\u8981\u4fee\u6539\u9876\u70b9\u7740\u8272\u5668\u3002 #version 110 attribute vec2 vert; attribute vec3 in_color; varying vec3 out_color; // \u4f60\u53ef\u4ee5\u770b\u5230\u6211\u4eec\u6dfb\u52a0\u4e86\u4e00\u4e2a\u77e9\u9635\u3002 uniform mat4 orthoMatrix; void main() { // \u8be5\u77e9\u9635\u5c06\u5bf9vert\u8fdb\u884c\u4e58\u6cd5\u64cd\u4f5c\u3002 gl_Position = orthoMatrix * vec4(vert, 0, 1); out_color = in_color; } \u73b0\u5728\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002\u6211\u4eec\u5728 GameRenderer \u4e2d\u5b9e\u4f8b\u5316\u6211\u4eec\u7684 Transformation \uff0c\u5e76\u5728\u6e32\u67d3\u65f6\u83b7\u53d6\u77e9\u9635\u3002 \u6211\u4eec\u8fd8\u9700\u8981\u4fee\u6539\u9876\u70b9\u4f4d\u7f6e\u4ee5\u5bf9\u5e94\u5c4f\u5e55\u5750\u6807\u7cfb\u3002 float[] vertices = { // \u5de6\u4e0a 0, 0, // \u5de6\u4e0b 0, 256, // \u53f3\u4e0b 256, 256, }; \u6211\u4eec\u5c06\u5728 program#bind \u4e4b\u540e\u8bbe\u7f6e uniform \u3002 try (MemoryStack stack = MemoryStack.stackPush()) { glUniformMatrix4fv(program.getUniform(\"orthoMatrix\"), false, transformation.getOrthoMatrix(block, window.getWidth(), window.getHeight()) .get(stack.mallocFloat(16))); } \u4e00\u5207\u51c6\u5907\u5c31\u7eea\u3002 \u5750\u548c\u653e\u5bbd\u3002 \u6211\u4eec\u53ea\u9700\u8981\u5904\u7406\u952e\u76d8\u8f93\u5165\u5373\u53ef\u6d4b\u8bd5\u4e09\u89d2\u5f62\u7684\u79fb\u52a8\u3001\u65cb\u8f6c\u548c\u7f29\u653e\u3002 \u6211\u4eec\u5c06\u770b\u5230\u4e0b\u56fe\uff1a \u5728\u793a\u4f8b\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u5df2\u7ecf\u90e8\u5206\u5b9e\u73b0\u4e86 \u6444\u50cf\u673a \u7684\u529f\u80fd\u3002\u53ea\u662f\u6211\u4eec\u6309\u4e0b\u952e\u76d8\u65f6\u4f1a\u628a\u4e09\u89d2\u5f62\u7684\u5750\u6807\u6539\u53d8\u3002","title":"\u77e9\u9635\u53d8\u6362"},{"location":"chapter2/texture/","text":"\u7eb9\u7406 \u5728\u7ed8\u5236\u51fa\u7eb9\u7406\u524d\uff0c\u6211\u4eec\u5148\u628a\u4e09\u89d2\u5f62\u53d8\u6210~~\u56db\u89d2\u5f62~~\u56db\u8fb9\u5f62\u3002 \u6211\u4eec\u5c06\u628a\u8fd9\u4e2a\u56db\u8fb9\u5f62\u770b\u505a\u662f\u4e24\u4e2a\u4e09\u89d2\u5f62\u800c\u4e0d\u662f GL_QUADS \u3002 \u6211\u4eec\u5c06\u4f7f\u7528 Mesh \u6765\u5904\u7406\u3002\u8fd9\u6837\u4fbf\u65e0\u9700\u8ba9\u6e32\u67d3\u5668\u6765\u5904\u7406\u3002 \u6211\u4eec\u8fd8\u9700\u8981\u4fee\u6539\u7740\u8272\u5668\uff0c\u4ee5\u9002\u5e94\u65b0\u7684\u66f4\u6539\u3002 #version 110 attribute vec2 vert; attribute vec3 in_color; // \u6211\u4eec\u65b0\u6dfb\u4e862\u4e2a\u6210\u5458\u3002 attribute vec2 in_texCoord; varying vec3 out_color; varying vec2 out_texCoord; uniform mat4 orthoMatrix; void main() { gl_Position = orthoMatrix * vec4(vert, 0.0, 1.0); out_color = in_color; out_texCoord = in_texCoord; } #version 110 varying vec3 out_color; varying vec2 out_texCoord; // \u7eb9\u7406\u91c7\u6837\u5668 uniform sampler2D textureSampler; void main() { // \u6211\u4eec\u5c06\u751f\u62102D\u7eb9\u7406\u5e76\u4e0e\u989c\u8272\u6df7\u5408\u3002 // \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5728\u56fa\u5b9a\u7ba1\u7ebf\u4e2d\u8c03\u7528glColor*(1, 1, 1)\u7684\u539f\u56e0\u3002 // \u5982\u679c\u4e0d\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff0c\u90a3\u4e48\u989c\u8272\u5168\u90e8\u90fd\u4f1a\u4e580\uff0c\u7ed3\u679c\u4e3a\u9ed1\u8272\u3002 gl_FragColor = texture2D(textureSampler, out_texCoord) * vec4(out_color, 1.0); } \u6211\u4eec\u8fd8\u4f7f\u7528\u4e86 Textures \u7c7b\uff0c\u7528\u4e8e\u5feb\u901f\u521b\u5efa\u7eb9\u7406\u3002 \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u6e32\u67d3\u5668\u4e86\u3002 \u628a\u4e4b\u524d\u7684vbo\u4ee3\u7801\u5168\u90e8\u5220\u9664\uff0c\u6362\u4e0a\u5168\u65b0\u7684 Mesh \u3002 mesh = Mesh.builder() .program(program) .vertices(vertices) .vertIdx(\"vert\") .vertSize(2) .colors(colors) .colorIdx(\"in_color\") .texCoords(texCoords) .texIdx(\"in_texCoord\") // \u7531\u4e8eGLUtils 0.3.0\u4e2d\u7684bug\uff0c\u6211\u4eec\u9700\u8981\u624b\u52a8\u8bbe\u7f6etexSize\u4e3a2.\u7b490.4.0\u5427 .texSize(2) .texture(Textures.loadAWT(GameRenderer.class.getClassLoader(), \"grass_block.png\", GL_NEAREST)) .indices(indices) .build(); \u4f60\u53ef\u4ee5\u770b\u5230\uff0c\u6211\u4eec\u4f7f\u7528\u4e86AWT\u6765\u8bfb\u53d6\u56fe\u7247\u3002\u8fd9\u662f\u56e0\u4e3astb\u662f\u672c\u5730\u5e93\uff0c\u5b83\u65e0\u6cd5\u83b7\u53d6\u4e0eClasspath\u6709\u5173\u7684\u4e1c\u897f\uff0c\u4f7f\u6211\u4eec\u53ea\u80fd\u7528\u7edd\u5bf9\u8def\u5f84\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u4e00\u4e2a\u8349\u65b9\u5757\u4f5c\u4e3a\u7eb9\u7406\u3002 \u7136\u540e\u6211\u4eec\u8bbe\u7f6e textureSampler \u4e3a0\uff1a program.setUniform(\"textureSampler\", 0) \u63a5\u7740\u628a glDrawArrays \u66ff\u6362\u4e3a mesh.render() \u3002 \u6700\u540e\uff0c\u6211\u4eec\u5728 close \u91cc\u91ca\u653e\u5185\u5b58\uff1a mesh.close() \u3002 \u542f\u52a8\u540e\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u4e00\u4e2a\u80fd\u52a8\u7684\u8349\u65b9\u5757\u3002","title":"\u7eb9\u7406"},{"location":"chapter2/texture/#_1","text":"\u5728\u7ed8\u5236\u51fa\u7eb9\u7406\u524d\uff0c\u6211\u4eec\u5148\u628a\u4e09\u89d2\u5f62\u53d8\u6210~~\u56db\u89d2\u5f62~~\u56db\u8fb9\u5f62\u3002 \u6211\u4eec\u5c06\u628a\u8fd9\u4e2a\u56db\u8fb9\u5f62\u770b\u505a\u662f\u4e24\u4e2a\u4e09\u89d2\u5f62\u800c\u4e0d\u662f GL_QUADS \u3002 \u6211\u4eec\u5c06\u4f7f\u7528 Mesh \u6765\u5904\u7406\u3002\u8fd9\u6837\u4fbf\u65e0\u9700\u8ba9\u6e32\u67d3\u5668\u6765\u5904\u7406\u3002 \u6211\u4eec\u8fd8\u9700\u8981\u4fee\u6539\u7740\u8272\u5668\uff0c\u4ee5\u9002\u5e94\u65b0\u7684\u66f4\u6539\u3002 #version 110 attribute vec2 vert; attribute vec3 in_color; // \u6211\u4eec\u65b0\u6dfb\u4e862\u4e2a\u6210\u5458\u3002 attribute vec2 in_texCoord; varying vec3 out_color; varying vec2 out_texCoord; uniform mat4 orthoMatrix; void main() { gl_Position = orthoMatrix * vec4(vert, 0.0, 1.0); out_color = in_color; out_texCoord = in_texCoord; } #version 110 varying vec3 out_color; varying vec2 out_texCoord; // \u7eb9\u7406\u91c7\u6837\u5668 uniform sampler2D textureSampler; void main() { // \u6211\u4eec\u5c06\u751f\u62102D\u7eb9\u7406\u5e76\u4e0e\u989c\u8272\u6df7\u5408\u3002 // \u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5728\u56fa\u5b9a\u7ba1\u7ebf\u4e2d\u8c03\u7528glColor*(1, 1, 1)\u7684\u539f\u56e0\u3002 // \u5982\u679c\u4e0d\u8c03\u7528\u8fd9\u4e2a\u51fd\u6570\uff0c\u90a3\u4e48\u989c\u8272\u5168\u90e8\u90fd\u4f1a\u4e580\uff0c\u7ed3\u679c\u4e3a\u9ed1\u8272\u3002 gl_FragColor = texture2D(textureSampler, out_texCoord) * vec4(out_color, 1.0); } \u6211\u4eec\u8fd8\u4f7f\u7528\u4e86 Textures \u7c7b\uff0c\u7528\u4e8e\u5feb\u901f\u521b\u5efa\u7eb9\u7406\u3002 \u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u4fee\u6539\u6e32\u67d3\u5668\u4e86\u3002 \u628a\u4e4b\u524d\u7684vbo\u4ee3\u7801\u5168\u90e8\u5220\u9664\uff0c\u6362\u4e0a\u5168\u65b0\u7684 Mesh \u3002 mesh = Mesh.builder() .program(program) .vertices(vertices) .vertIdx(\"vert\") .vertSize(2) .colors(colors) .colorIdx(\"in_color\") .texCoords(texCoords) .texIdx(\"in_texCoord\") // \u7531\u4e8eGLUtils 0.3.0\u4e2d\u7684bug\uff0c\u6211\u4eec\u9700\u8981\u624b\u52a8\u8bbe\u7f6etexSize\u4e3a2.\u7b490.4.0\u5427 .texSize(2) .texture(Textures.loadAWT(GameRenderer.class.getClassLoader(), \"grass_block.png\", GL_NEAREST)) .indices(indices) .build(); \u4f60\u53ef\u4ee5\u770b\u5230\uff0c\u6211\u4eec\u4f7f\u7528\u4e86AWT\u6765\u8bfb\u53d6\u56fe\u7247\u3002\u8fd9\u662f\u56e0\u4e3astb\u662f\u672c\u5730\u5e93\uff0c\u5b83\u65e0\u6cd5\u83b7\u53d6\u4e0eClasspath\u6709\u5173\u7684\u4e1c\u897f\uff0c\u4f7f\u6211\u4eec\u53ea\u80fd\u7528\u7edd\u5bf9\u8def\u5f84\u3002 \u6211\u4eec\u4f7f\u7528\u4e86\u4e00\u4e2a\u8349\u65b9\u5757\u4f5c\u4e3a\u7eb9\u7406\u3002 \u7136\u540e\u6211\u4eec\u8bbe\u7f6e textureSampler \u4e3a0\uff1a program.setUniform(\"textureSampler\", 0) \u63a5\u7740\u628a glDrawArrays \u66ff\u6362\u4e3a mesh.render() \u3002 \u6700\u540e\uff0c\u6211\u4eec\u5728 close \u91cc\u91ca\u653e\u5185\u5b58\uff1a mesh.close() \u3002 \u542f\u52a8\u540e\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u4e00\u4e2a\u80fd\u52a8\u7684\u8349\u65b9\u5757\u3002","title":"\u7eb9\u7406"}]}